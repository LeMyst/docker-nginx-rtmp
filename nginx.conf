error_log /dev/stdout info;

events {
	worker_connections 1024;
}

rtmp {
	rtmp_relay_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;

	server {
		listen ${RTMP_PORT};
		chunk_size 4000;
		ping 30s;
		ping_timeout 15s;

		application stream {
			live on;

			exec ffmpeg -i rtmp://localhost:1935/stream/$name
			  -c:a libfdk_aac -b:a 128k -c:v libx264 -b:v 2500k -f flv -g 30 -r 30 -s 1280x720 -preset superfast -profile:v baseline rtmp://localhost:1935/hls/$name_720p2628kbs
			  -c:a libfdk_aac -b:a 128k -c:v libx264 -b:v 1000k -f flv -g 30 -r 30 -s 854x480 -preset superfast -profile:v baseline rtmp://localhost:1935/hls/$name_480p1128kbs
			  -c:a libfdk_aac -b:a 128k -c:v libx264 -b:v 750k -f flv -g 30 -r 30 -s 640x360 -preset superfast -profile:v baseline rtmp://localhost:1935/hls/$name_360p878kbs
			  -c:a libfdk_aac -b:a 128k -c:v libx264 -b:v 400k -f flv -g 30 -r 30 -s 426x240 -preset superfast -profile:v baseline rtmp://localhost:1935/hls/$name_240p528kbs
			  -c:a libfdk_aac -b:a 64k -c:v libx264 -b:v 200k -f flv -g 15 -r 15 -s 426x240 -preset superfast -profile:v baseline rtmp://localhost:1935/hls/$name_240p264kbs;
		}

		application hls {
			live on;

			hls on;
			hls_fragment_naming system;
			hls_fragment 5;
			hls_playlist_length 10;
			hls_path /opt/data/hls;
			hls_nested on;

			allow publish 127.0.0.1;  # Publish received from the exec of application stream.
			deny publish all;  # Deny publishing from all other IPs.

			hls_variant _720p2628kbs BANDWIDTH=2628000,RESOLUTION=1280x720;
			hls_variant _480p1128kbs BANDWIDTH=1128000,RESOLUTION=854x480;
			hls_variant _360p878kbs BANDWIDTH=878000,RESOLUTION=640x360;
			hls_variant _240p528kbs BANDWIDTH=528000,RESOLUTION=426x240;
			hls_variant _240p264kbs BANDWIDTH=264000,RESOLUTION=426x240;
		}

		application multistream {
			live on;

			pull rtmp://127.0.0.1/program/stream name=live static;

			allow publish 127.0.0.1;
			deny publish all;
			deny play all;

			# Push the incoming stream to Twitch's RTMP ingest server.
			#push rtmp://ingest.global-contribute.live-video.net/app/stream_key;
			# Push the incoming stream to Youtube's RTMP ingest server.
			#push rtmp://a.rtmp.youtube.com/live2/stream_key;
			# Push the incoming stream to Steam's RTMP ingest server.
			#push rtmp://ingest-rtmp.broadcast.steamcontent.com/app/stream_key;
		}

		# Inspired by https://coders-home.de/nginx-rtmp-mit-standby-bild-wenn-kein-publisher-verbunden-ist-1269.html

		# Publish from OBS to http://<server_ip>:1935/publish/livefeed

		application publish {
			live on;

			# Support for stream key verification.
			# This is optional, but recommended if you want to prevent unauthorized streaming to your server.
			on_publish http://auth:5000/auth;

			wait_video on;
			wait_key on;
			exec_options on;

			push rtmp://127.0.0.1/live_source/raw;

			# When publish start, we switch the stream in the switcher application to the online stream and push the incoming stream to the program application.
			# When publish stops, we switch the stream in the switcher application back to the offline stream.
			exec_publish curl "http://127.0.0.1/control/redirect/subscriber?app=switcher&newname=online";
			exec_publish_done curl "http://127.0.0.1/control/redirect/subscriber?app=switcher&newname=offline";
		}

		application live_source {
			live on;
			allow publish 127.0.0.1;
			deny publish all;
		}

		application switcher {
			live on;

			# Deny publishing and only allow playing from localhost.
			# It's only for switching between the offline and online stream.
			deny publish all;
			allow play 127.0.0.1;  # Play received from the pull of application program.
			deny play all;

			# Offline loop
			pull rtmp://127.0.0.1/fallback/static_image name=offline;

			# Online stream
			pull rtmp://127.0.0.1/live_source/raw name=online;
		}

		application program {
			live on;

			deny publish all;  # Deny publishing to this application. It's only for pulling and pushing streams.
			allow play 127.0.0.1;  # Play received from the pull of application multistream.
			deny play all;

			# At startup, pull the offline stream and push it to multistream. This way, you can have a default stream that is shown when no one is streaming live.
			pull rtmp://127.0.0.1/switcher/offline name=stream static;
		}

		application fallback {
			live on;

			# Deny publishing and only allow playing from localhost.
			# It's only for switching between the offline and online stream.
			allow publish 127.0.0.1;  # Publish received from the exec_pull of application fallback.
			deny publish all;
			allow play 127.0.0.1;  # Play received from the pull of application switcher.
			deny play all;

			wait_video on;
			wait_key on;

			exec_options on;

			exec_pull ffmpeg -re -f image2 -loop 1 -framerate 25 -i /etc/nginx/tech_diff_fred_seibert_cc-by-nc-nd-2.jpg -f lavfi -i "anullsrc=channel_layout=stereo:sample_rate=48000" -map 0:v -map 1:a -c:v libx264 -preset veryfast -tune stillimage -profile:v baseline -level 3.1 -b:v 800k -maxrate 900k -bufsize 1600k -g 50 -vf "scale=1920:1080,format=yuv420p" -r 25 -c:a aac -b:a 128k -ac 2 -ar 48000 -f flv -rtmp_live live rtmp://127.0.0.1/fallback/static_image;
		}
	}
}

http {
	root /srv/www/static;
	sendfile off;
	tcp_nopush on;
	server_tokens off;
	access_log /dev/stdout combined;

	# Uncomment these lines to enable SSL.
	# ssl_protocols TLSv1.2 TLSv1.3;
	# ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
	# ssl_prefer_server_ciphers off;
	# ssl_session_cache shared:SSL:10m;
	# ssl_session_timeout 1d;

	server {
		listen ${HTTP_PORT};

		# Uncomment these lines to enable SSL.
		# Update the ssl paths with your own certificate and private key.

		#listen ${HTTPS_PORT} ssl;
		#ssl_certificate		/opt/certs/example.com.crt;
		#ssl_certificate_key	/opt/certs/example.com.key;

		# HLS stream location
		location /hls {
			types {
				application/vnd.apple.mpegurl m3u8;
				video/mp2t ts;
			}
			root /opt/data;
			add_header Cache-Control no-cache;
			add_header Access-Control-Allow-Origin *;
		}

		# HLS live stream location
		location /live {
		  alias /opt/data/hls;
		  types {
			  application/vnd.apple.mpegurl m3u8;
			  video/mp2t ts;
		  }
		  add_header Cache-Control no-cache;
		  add_header Access-Control-Allow-Origin *;
		}

		# RTMP control location
		# Lets you control your RTMP server with HTTP commands
		location /control {
			rtmp_control all;

			satisfy any;  # Allow access if the client is from the local network or if they provide valid authentication.
			allow 10.0.0.0/8;  # Allow access from your local network.
			allow 127.0.0.0/8;  # Allow access from localhost.
			allow 172.16.0.0/12;  # Allow access from your local network.
			allow 192.168.0.0/16;  # Allow access from your local network.
			deny all;  # Deny access from all other IPs.
			auth_basic "Restricted Content";
			auth_basic_user_file /etc/nginx/htpasswd;
		}

		# RTMP stat location
		# Lets you monitor your RTMP server status
		location /stat {
			rtmp_stat all;
			rtmp_stat_stylesheet stat.xsl;

			satisfy any;  # Allow access if the client is from the local network or if they provide valid authentication.
			allow 10.0.0.0/8;  # Allow access from your local network.
			allow 127.0.0.0/8;  # Allow access from localhost.
			allow 172.16.0.0/12;  # Allow access from your local network.
			allow 192.168.0.0/16;  # Allow access from your local network.
			deny all;  # Deny access from all other IPs.
			auth_basic "Restricted Content";
			auth_basic_user_file /etc/nginx/htpasswd;
		}

		# RTMP stat xsl location
		# Stylesheet file for RTMP stat location
		location /stat.xsl {
			root /srv/www/static;
		}

		# Crossdomain file location
		# Lets Flash players connect from other domains
		location /crossdomain.xml {
			default_type text/xml;
			expires 24h;
		}
	}
}
